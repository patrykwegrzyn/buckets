{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport {\n  Database,\n  DatabaseOptions,\n  Key,\n  open,\n  RootDatabase,\n  RootDatabaseOptions,\n} from \"lmdbx\";\n\nexport type PutOptions = {\n  version?: number;\n  ttl?: number;\n  ifVersion?: number;\n  quiet?: boolean;\n};\n\nexport type RemoveOptions = {\n  quiet?: boolean;\n  ifVersion?: number;\n};\n\ninterface DefaultSerializer<V> {\n  encoder: { encode: (value: V) => Buffer | string };\n  decoder: { decode: (value: Buffer | string) => V };\n  encoding: string;\n}\n\nexport type ExtendedRootDb = RootDatabase & {\n  committed: () => Promise<void>;\n};\n\nexport type BucketOptions = DatabaseOptions & {\n  indexes?: string[];\n};\n\ntype DB<V = any, K extends Key = Key> = Database<V, K> & DefaultSerializer<V>;\n\nexport interface WrappedDB<V = any, K extends Key = Key>\n  extends Omit<Database<V, K>, \"put\" | \"remove\">,\n    DefaultSerializer<V> {\n  put(id: K, value: V, options?: PutOptions): Promise<boolean>;\n  remove(id: K, options?: RemoveOptions): Promise<boolean>;\n  query(indexName: string, value: any): Promise<V[]>;\n}\n\nexport class Store<V = any, K extends Key = Key> extends EventEmitter {\n  protected env: ExtendedRootDb;\n  // Open the TTL bucket directly so it's not wrapped.\n  protected ttlBucket: Database<string, string>;\n  protected indexDb: Database<string, K>;\n  protected dbs = new Map<string, WrappedDB<any, K>>();\n  protected flushing: boolean = false;\n  protected indexes = new Map<string, string[]>();\n\n  constructor(name: string, options: RootDatabaseOptions) {\n    super();\n    this.env = open(name, options) as ExtendedRootDb;\n    // Open TTL bucket directly.\n    this.ttlBucket = this.env.openDB(\"ttl\", { cache: true });\n    this.indexDb = this.env.openDB(\"index\", { cache: true });\n  }\n\n  protected ttlKey(exp: number, bucket: string, key: string): string {\n    return `${exp}:${bucket}:${key}`;\n  }\n\n  async committed() {\n    return this.env.committed;\n  }\n\n  /**\n   * Wrap a raw DB so that it supports custom put, remove, and query logic.\n   */\n  protected wrapDB<TV>(db: DB<TV, K>, bucketName: string): WrappedDB<TV, K> {\n    const wrapped: Partial<WrappedDB<TV, K>> = Object.create(db);\n\n    wrapped.query = async (indexName: string, value: any) => {\n      const keys: K[] = [];\n      const prefix = this.indexKey(bucketName, indexName, value);\n      for (const { value: idxValue } of this.indexDb.getRange({\n        start: prefix,\n        end: `${prefix}\\xff`,\n      })) {\n        keys.push(idxValue as K);\n      }\n      const results = await db.getMany(keys);\n      return results.filter((item): item is TV => item !== undefined);\n    };\n\n    wrapped.put = (\n      id: K,\n      value: TV,\n      options?: PutOptions\n    ): Promise<boolean> => {\n      let result: Promise<boolean>;\n      if (options?.version !== undefined && options.ifVersion !== undefined) {\n        result = db.put(id, value, options.version, options.ifVersion);\n      } else if (options?.version !== undefined) {\n        result = db.put(id, value, options.version);\n      } else {\n        result = db.put(id, value);\n      }\n\n      // Handle TTL: if ttl option is provided, schedule deletion by adding a TTL entry.\n      if (options?.ttl) {\n        const exp = Date.now() + options.ttl;\n        const ttlEntryKey = this.ttlKey(exp, bucketName, String(id));\n        this.ttlBucket.put(ttlEntryKey, \"\");\n      }\n\n      // Handle indexes if defined.\n      const indexKeys = this.indexes.get(bucketName);\n      if (indexKeys) {\n        for (const key of indexKeys) {\n          const indexVal = (value as any)[key];\n          const composite = this.indexKey(bucketName, key, indexVal, id as any);\n          this.indexDb.put(composite as K, String(id));\n        }\n      }\n\n      if (!options?.quiet) {\n        this.emit(\"change\", {\n          op: \"put\",\n          bucket: bucketName,\n          id,\n          value: db.encoder.encode(value),\n          version: options?.version,\n          ttl: options?.ttl,\n        });\n      }\n      return result;\n    };\n\n    wrapped.remove = (id: K, options?: RemoveOptions): Promise<boolean> => {\n      // Retrieve current value only once.\n      const current = db.get(id);\n\n      // Remove any associated indexes.\n      const indexKeys = this.indexes.get(bucketName);\n      if (indexKeys && current) {\n        for (const key of indexKeys) {\n          const indexVal = (current as any)[key];\n          const composite = this.indexKey(bucketName, key, indexVal, id as any);\n          this.indexDb.remove(composite as K);\n        }\n      }\n\n      if (!options?.quiet) {\n        this.emit(\"change\", {\n          op: \"remove\",\n          bucket: bucketName,\n          id,\n          value: current,\n          version: options?.ifVersion,\n        });\n      }\n\n      if (options?.ifVersion !== undefined) {\n        return db.remove(id, options.ifVersion);\n      }\n      return db.remove(id);\n    };\n\n    // Return the wrapped object cast to WrappedDB.\n    return wrapped as WrappedDB<TV, K>;\n  }\n\n  /**\n   * Generate a composite index key.\n   * This implementation uses a simple colon-delimited string,\n   * omitting undefined parts.\n   */\n  private indexKey(bucket: string, index: string, value: any, key?: string) {\n    return [bucket, index, value, key].filter((v) => v !== undefined).join(\":\");\n  }\n\n  /**\n   * Open or create a bucket in the store.\n   */\n  bucket<TV = any>(name: string, options?: BucketOptions): WrappedDB<TV, K> {\n    let db = this.dbs.get(name);\n    if (!db) {\n      const opts: DatabaseOptions = { cache: true, ...options };\n      const raw = this.env.openDB<TV, K>(name, opts) as DB<TV, K>;\n      db = this.wrapDB(raw, name);\n      if (options?.indexes) {\n        this.indexes.set(name, options.indexes);\n      }\n      this.dbs.set(name, db);\n    }\n    return db;\n  }\n\n  /**\n   * Clean expired entries based on TTL.\n   */\n  async clean() {\n    if (this.flushing) return;\n    this.flushing = true;\n\n    const keysToDelete: Array<{\n      ttlKey: string;\n      bucketName: string;\n      id: string;\n    }> = [];\n    const nowStr = Date.now().toString();\n\n    for (const key of this.ttlBucket.getKeys({ end: nowStr })) {\n      const parts = key.split(\":\");\n      if (parts.length < 3) continue;\n      const bucketName = parts[1];\n      const id = parts.slice(2).join(\":\");\n      keysToDelete.push({ ttlKey: key, bucketName, id });\n    }\n\n    await this.env.transaction(() => {\n      for (const { ttlKey, bucketName, id } of keysToDelete) {\n        const bucket = this.bucket(bucketName);\n        bucket.remove(id as K, { quiet: true });\n        this.ttlBucket.remove(ttlKey);\n      }\n    });\n\n    this.flushing = false;\n  }\n\n  /**\n   * Close all open databases.\n   */\n  async close() {\n    const dbs = Array.from(this.dbs.values()).map((db) => db.close());\n    await Promise.all([...dbs, this.env.close(), this.ttlBucket.close()]);\n  }\n}\n"],"mappings":"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","names":["EventEmitter","open","Store","name","options","exp","bucket","key","db","bucketName","wrapped","indexName","value","keys","prefix","idxValue","item","id","result","ttlEntryKey","indexKeys","indexVal","composite","current","index","v","opts","raw","keysToDelete","nowStr","parts","ttlKey","dbs"]}
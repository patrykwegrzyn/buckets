{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport {\n  Database,\n  DatabaseOptions,\n  Key,\n  open,\n  RootDatabase,\n  RootDatabaseOptions,\n} from \"lmdb\";\n\nexport type PutOptions = {\n  version?: number;\n  ttl?: number; // TTL in milliseconds\n  ifVersion?: number;\n  quiet?: boolean;\n};\n\nexport type RemoveOptions = {\n  quiet?: boolean;\n  ifVersion?: number;\n};\n\ninterface DefaultSerializer<V> {\n  encoder: { encode: (value: V) => Buffer };\n  decoder: { encode: (value: Buffer) => V };\n}\n\n// This is the original LMDBx DB type plus our serializer.\ntype DB<V = any, K extends Key = Key> = Database<V, K> & DefaultSerializer<V>;\n\n// Define our wrapped DB interface: we omit the original put/remove and add our simplified versions.\nexport interface WrappedDB<V = any, K extends Key = Key>\n  extends Omit<Database<V, K>, \"put\" | \"remove\">,\n    DefaultSerializer<V> {\n  put(id: K, value: V, options?: PutOptions): Promise<boolean>;\n  remove(id: K, options?: RemoveOptions): Promise<boolean>;\n}\n\nexport class Store<V = any, K extends Key = Key> extends EventEmitter {\n  protected env: RootDatabase;\n  // Open the TTL bucket directly so it's not wrapped.\n  protected ttlBucket: Database<string, string>;\n  protected dbs: Map<string, WrappedDB<any, K>>;\n  protected flushing: boolean = false;\n\n  constructor(name: string, options: RootDatabaseOptions) {\n    super();\n    this.dbs = new Map();\n    this.env = open(name, options);\n    // Open TTL bucket directly.\n    this.ttlBucket = this.env.openDB(\"ttl\", { cache: true });\n  }\n\n  // Build a TTL key in the format \"exp:bucket:key\"\n  protected ttlKey(exp: number, bucket: string, key: string): string {\n    return `${exp}:${bucket}:${key}`;\n  }\n\n  /**\n   * Wrap a given DB instance using a levelup-style approach.\n   * All methods and properties are available via the prototype,\n   * but we override put and remove with our custom implementations.\n   */\n  protected wrapDB<TV>(db: DB<TV, K>, bucketName: string): WrappedDB<TV, K> {\n    const self = this;\n    // Start with a Partial of our WrappedDB, using Object.create to inherit original methods.\n    const wrapped: Partial<WrappedDB<TV, K>> = Object.create(db);\n\n    // Override put with our custom logic and proper type annotation.\n    wrapped.put = function (\n      id: K,\n      value: TV,\n      options?: PutOptions\n    ): Promise<boolean> {\n      let result: Promise<boolean>;\n      if (\n        options &&\n        options.version !== undefined &&\n        options.ifVersion !== undefined\n      ) {\n        result = db.put(id, value, options.version, options.ifVersion);\n      } else if (options && options.version !== undefined) {\n        result = db.put(id, value, options.version);\n      } else {\n        result = db.put(id, value);\n      }\n\n      if (options?.ttl) {\n        const exp = Date.now() + options.ttl;\n        const ttlEntryKey = self.ttlKey(exp, bucketName, String(id));\n        self.ttlBucket.put(ttlEntryKey, \"\");\n      }\n\n      if (!options?.quiet) {\n        self.emit(\"change\", {\n          op: \"put\",\n          bucket: bucketName,\n          id,\n          value: db.encoder.encode(value),\n          version: options?.version,\n          ttl: options?.ttl,\n        });\n      }\n      return result;\n    };\n\n    // Override remove with our custom logic and proper type annotation.\n    wrapped.remove = function (\n      id: K,\n      options?: RemoveOptions\n    ): Promise<boolean> {\n      if (!options?.quiet) {\n        const current = db.get(id);\n        self.emit(\"change\", {\n          op: \"remove\",\n          bucket: bucketName,\n          id,\n          value: current,\n          version: options?.ifVersion,\n        });\n      }\n      if (options?.ifVersion !== undefined) {\n        return db.remove(id, options.ifVersion);\n      }\n      return db.remove(id);\n    };\n\n    // Return the wrapped object cast to WrappedDB.\n    return wrapped as WrappedDB<TV, K>;\n  }\n\n  /**\n   * Retrieve or create a sub-database.\n   * The returned instance is wrapped so that our custom put/remove\n   * (with TTL and change event functionality) are available.\n   */\n  bucket<TV = any>(name: string, options?: DatabaseOptions): WrappedDB<TV, K> {\n    let db = this.dbs.get(name);\n    if (!db) {\n      const opts: DatabaseOptions = { cache: true, ...options };\n      const raw = this.env.openDB<TV, K>(name, opts) as DB<TV, K>;\n      db = this.wrapDB(raw, name);\n      this.dbs.set(name, db);\n    }\n    return db;\n  }\n\n  /**\n   * Clean up expired TTL entries in batch.\n   */\n  async clean() {\n    if (this.flushing) return;\n    this.flushing = true;\n\n    const keysToDelete: Array<{\n      ttlKey: string;\n      bucketName: string;\n      id: string;\n    }> = [];\n    const now = Date.now().toString();\n\n    for (const key of this.ttlBucket.getKeys({ end: now })) {\n      const parts = key.split(\":\");\n      if (parts.length < 3) continue;\n      const bucketName = parts[1];\n      const id = parts.slice(2).join(\":\");\n      keysToDelete.push({ ttlKey: key, bucketName, id });\n    }\n\n    await this.env.transaction(() => {\n      for (const { ttlKey, bucketName, id } of keysToDelete) {\n        const bucket = this.bucket(bucketName);\n        bucket.remove(id as K, { quiet: true });\n        this.ttlBucket.remove(ttlKey);\n      }\n    });\n\n    this.flushing = false;\n  }\n}\n"],"mappings":"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","names":["EventEmitter","open","Store","name","options","exp","bucket","key","db","bucketName","self","wrapped","id","value","result","ttlEntryKey","current","opts","raw","keysToDelete","now","parts","ttlKey"]}
{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport {\n  Database,\n  DatabaseOptions,\n  Key,\n  open,\n  RootDatabase,\n  RootDatabaseOptions,\n} from \"lmdbx\";\n\nexport type PutOptions = {\n  version?: number;\n  ttl?: number; // TTL in milliseconds\n  ifVersion?: number;\n  quiet?: boolean;\n};\n\nexport type RemoveOptions = {\n  quiet?: boolean;\n  ifVersion?: number;\n};\n\ninterface DefaultSerializer<V> {\n  encoder: { encode: (value: V) => Buffer };\n  decoder: { encode: (value: Buffer) => V };\n}\n\ntype BucketOptions = DatabaseOptions & {\n  indexes?: string[];\n};\n\n// This is the original LMDBx DB type plus our serializer.\ntype DB<V = any, K extends Key = Key> = Database<V, K> & DefaultSerializer<V>;\n\n// Define our wrapped DB interface: we omit the original put/remove and add our simplified versions.\nexport interface WrappedDB<V = any, K extends Key = Key>\n  extends Omit<Database<V, K>, \"put\" | \"remove\">,\n    DefaultSerializer<V> {\n  put(id: K, value: V, options?: PutOptions): Promise<boolean>;\n  remove(id: K, options?: RemoveOptions): Promise<boolean>;\n  query(indexName: string, value: any): Promise<V[]>;\n}\n\nexport class Store<V = any, K extends Key = Key> extends EventEmitter {\n  protected env: RootDatabase;\n  // Open the TTL bucket directly so it's not wrapped.\n  protected ttlBucket: Database<string, string>;\n  protected indexDb: Database<string, K>;\n  protected dbs = new Map<string, WrappedDB<any, K>>();\n  protected flushing: boolean = false;\n  protected indexes = new Map<string, string[]>();\n\n  constructor(name: string, options: RootDatabaseOptions) {\n    super();\n    this.env = open(name, options);\n    // Open TTL bucket directly.\n    this.ttlBucket = this.env.openDB(\"ttl\", { cache: true });\n    this.indexDb = this.env.openDB(\"index\", { cache: true });\n  }\n\n  // Build a TTL key in the format \"exp:bucket:key\"\n  protected ttlKey(exp: number, bucket: string, key: string): string {\n    return `${exp}:${bucket}:${key}`;\n  }\n\n  /**\n   * Wrap a given DB instance using a levelup-style approach.\n   * All methods and properties are available via the prototype,\n   * but we override put and remove with our custom implementations.\n   */\n  protected wrapDB<TV>(db: DB<TV, K>, bucketName: string): WrappedDB<TV, K> {\n    const self = this;\n    // Start with a Partial of our WrappedDB, using Object.create to inherit original methods.\n    const wrapped: Partial<WrappedDB<TV, K>> = Object.create(db);\n\n    wrapped.query = async function (indexName: string, value: any) {\n      console.log(\"query\", indexName, value);\n      const keys: K[] = [];\n      const prefix = self.indexKey(bucketName, indexName, value);\n      for (let { key, value } of self.indexDb.getRange({\n        start: prefix,\n        end: `${prefix}\\xff`,\n      })) {\n        console.log({ key, value });\n        keys.push(value as K);\n        // for each key-value pair in the given range\n      }\n\n      const results = await db.getMany(keys);\n      return results.filter((item): item is TV => item !== undefined);\n    };\n\n    // Override put with our custom logic and proper type annotation.\n    wrapped.put = function (\n      id: K,\n      value: TV,\n      options?: PutOptions\n    ): Promise<boolean> {\n      let result: Promise<boolean>;\n      if (\n        options &&\n        options.version !== undefined &&\n        options.ifVersion !== undefined\n      ) {\n        result = db.put(id, value, options.version, options.ifVersion);\n      } else if (options && options.version !== undefined) {\n        result = db.put(id, value, options.version);\n      } else {\n        result = db.put(id, value);\n      }\n\n      if (options?.ttl) {\n        const exp = Date.now() + options.ttl;\n        const ttlEntryKey = self.ttlKey(exp, bucketName, String(id));\n        self.ttlBucket.put(ttlEntryKey, \"\");\n      }\n\n      const _indexKeys = self.indexes.get(bucketName);\n      if (_indexKeys) {\n        for (const k of _indexKeys) {\n          const indexVal = (value as any)[k];\n          const composite = self.indexKey(bucketName, k, indexVal, id as any);\n          self.indexDb.put(composite as K, String(id));\n        }\n      }\n\n      if (!options?.quiet) {\n        self.emit(\"change\", {\n          op: \"put\",\n          bucket: bucketName,\n          id,\n          value: db.encoder.encode(value),\n          version: options?.version,\n          ttl: options?.ttl,\n        });\n      }\n      return result;\n    };\n\n    // Override remove with our custom logic and proper type annotation.\n    wrapped.remove = function (\n      id: K,\n      options?: RemoveOptions\n    ): Promise<boolean> {\n      const _indexKeys = self.indexes.get(bucketName);\n\n      if (_indexKeys) {\n        const current = db.get(id);\n        for (const k of _indexKeys) {\n          const indexVal = (current as any)[k];\n          const composite = self.indexKey(bucketName, k, indexVal, id as any);\n          self.indexDb.remove(composite as K);\n        }\n      }\n\n      if (!options?.quiet) {\n        const current = db.get(id);\n        self.emit(\"change\", {\n          op: \"remove\",\n          bucket: bucketName,\n          id,\n          value: current,\n          version: options?.ifVersion,\n        });\n      }\n\n      if (options?.ifVersion !== undefined) {\n        return db.remove(id, options.ifVersion);\n      }\n\n      return db.remove(id);\n    };\n\n    // Return the wrapped object cast to WrappedDB.\n    return wrapped as WrappedDB<TV, K>;\n  }\n\n  private indexKey(bucket: string, index: string, value: any, key = \"\") {\n    return `${bucket}:${index}:${value}:${key}`;\n  }\n\n  /**\n   * Retrieve or create a sub-database.\n   * The returned instance is wrapped so that our custom put/remove\n   * (with TTL and change event functionality) are available.\n   */\n  bucket<TV = any>(name: string, options?: BucketOptions): WrappedDB<TV, K> {\n    let db = this.dbs.get(name);\n    if (!db) {\n      const opts: DatabaseOptions = { cache: true, ...options };\n      const raw = this.env.openDB<TV, K>(name, opts) as DB<TV, K>;\n      db = this.wrapDB(raw, name);\n      if (options?.indexes) {\n        this.indexes.set(name, options.indexes);\n      }\n      this.dbs.set(name, db);\n    }\n    return db;\n  }\n\n  /**\n   * Clean up expired TTL entries in batch.\n   */\n  async clean() {\n    if (this.flushing) return;\n    this.flushing = true;\n\n    const keysToDelete: Array<{\n      ttlKey: string;\n      bucketName: string;\n      id: string;\n    }> = [];\n    const now = Date.now().toString();\n\n    for (const key of this.ttlBucket.getKeys({ end: now })) {\n      const parts = key.split(\":\");\n      if (parts.length < 3) continue;\n      const bucketName = parts[1];\n      const id = parts.slice(2).join(\":\");\n      keysToDelete.push({ ttlKey: key, bucketName, id });\n    }\n\n    await this.env.transaction(() => {\n      for (const { ttlKey, bucketName, id } of keysToDelete) {\n        const bucket = this.bucket(bucketName);\n        bucket.remove(id as K, { quiet: true });\n        this.ttlBucket.remove(ttlKey);\n      }\n    });\n\n    this.flushing = false;\n  }\n\n  async close() {\n    const dbs = Array.from(this.dbs.values()).map((db) => db.close());\n    await Promise.all([...dbs, this.env.close(), this.ttlBucket.close()]);\n  }\n}\n"],"mappings":"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","names":["EventEmitter","open","Store","name","options","exp","bucket","key","db","bucketName","self","wrapped","indexName","value","keys","prefix","item","id","result","ttlEntryKey","_indexKeys","k","indexVal","composite","current","index","opts","raw","keysToDelete","now","parts","ttlKey","dbs"]}
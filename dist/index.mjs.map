{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport {\n  Database,\n  DatabaseOptions,\n  Key,\n  open,\n  RootDatabase,\n  RootDatabaseOptions,\n} from \"lmdbx\";\n\nexport type PutOptions = {\n  version?: number;\n  ttl?: number; // TTL in milliseconds\n  ifVersion?: number;\n  quiet?: boolean;\n};\n\nexport type RemoveOptions = {\n  quiet?: boolean;\n  ifVersion?: number;\n};\n\ninterface DefaultSerializer<V> {\n  encoder: { encode: (value: V) => Buffer };\n  decoder: { encode: (value: Buffer) => V };\n}\n\ntype DB<V = any, K extends Key = Key> = Database<V, K> & DefaultSerializer<V>;\n\nexport class Store<V = any, K extends Key = Key> extends EventEmitter {\n  protected env: RootDatabase;\n  // Open the TTL bucket directly so it's not patched (and no events are emitted).\n  protected ttlBucket: Database<string, string>;\n  protected dbs: Map<string, DB<any, K>>;\n  protected flushing: boolean = false;\n\n  constructor(name: string, options: RootDatabaseOptions) {\n    super();\n    this.dbs = new Map();\n    this.env = open(name, options);\n    // Open TTL bucket directly (bypassing our patching logic).\n    this.ttlBucket = this.env.openDB(\"ttl\", { cache: true });\n  }\n\n  // Build a TTL key in the format \"exp:bucket:key\"\n  protected ttlKey(exp: number, bucket: string, key: string): string {\n    return `${exp}:${bucket}:${key}`;\n  }\n\n  // Patch a given database to wrap its put and remove methods.\n  protected _patch(db: DB, bucketName: string) {\n    const origPut = db.put.bind(db);\n    const origRemove = db.remove.bind(db);\n    const self = this;\n\n    db.put = (\n      id: K,\n      value: V,\n      verOrOpts?: number | PutOptions,\n      ifVersion?: number\n    ) => {\n      let options: PutOptions = {};\n      let quiet = false;\n      if (typeof verOrOpts === \"number\") {\n        options.version = verOrOpts;\n      } else if (typeof verOrOpts === \"object\" && verOrOpts !== null) {\n        options = verOrOpts;\n        quiet = !!verOrOpts.quiet;\n      }\n\n      const result = origPut(id, value, options.version as number, ifVersion);\n\n      if (options.ttl) {\n        const exp = Date.now() + options.ttl;\n        const ttlEntryKey = self.ttlKey(exp, bucketName, String(id));\n        self.ttlBucket.put(ttlEntryKey, \"\");\n      }\n\n      if (!quiet) {\n        self.emit(\"change\", {\n          op: \"put\",\n          bucket: bucketName,\n          id,\n          value: db.encoder.encode(value),\n          version: options.version,\n          ttl: options.ttl,\n        });\n      }\n\n      return result;\n    };\n\n    db.remove = async (\n      id: K,\n      opts?: number | RemoveOptions\n    ): Promise<boolean> => {\n      let quiet = false;\n      let version: number | undefined;\n\n      if (typeof opts === \"number\") {\n        version = opts;\n      } else if (typeof opts === \"object\" && opts !== null) {\n        quiet = !!opts.quiet;\n        version = opts.ifVersion;\n      }\n\n      if (!quiet) {\n        const current = db.get(id);\n        self.emit(\"change\", {\n          op: \"remove\",\n          bucket: bucketName,\n          id,\n          value: current,\n          version,\n        });\n      }\n\n      if (typeof opts === \"object\" && opts !== null && opts.quiet) {\n        return origRemove(id, version);\n      }\n\n      return origRemove(id, opts as any);\n    };\n  }\n\n  // Retrieve or create a sub-database.\n  bucket<TV = any>(name: string, options?: DatabaseOptions): DB<TV, K> {\n    let db = this.dbs.get(name);\n\n    if (!db) {\n      const opts: DatabaseOptions = { cache: true, ...options };\n      db = this.env.openDB<TV, K>(name, opts) as DB<TV, K>;\n      this.dbs.set(name, db);\n      this._patch(db, name);\n    }\n\n    return db;\n  }\n\n  // Clean up expired TTL entries in batch.\n  async clean() {\n    if (this.flushing) return;\n    this.flushing = true;\n\n    const keysToDelete: Array<{\n      ttlKey: string;\n      bucketName: string;\n      id: string;\n    }> = [];\n\n    const now = Date.now().toString();\n\n    for (const key of this.ttlBucket.getKeys({ end: now })) {\n      const parts = key.split(\":\");\n      if (parts.length < 3) continue;\n      const bucketName = parts[1];\n      const id = parts.slice(2).join(\":\");\n      keysToDelete.push({ ttlKey: key, bucketName, id });\n    }\n\n    // Batch removal using a transaction\n    await this.env.transaction(() => {\n      for (const { ttlKey, bucketName, id } of keysToDelete) {\n        const bucket = this.bucket(bucketName);\n        bucket.remove(id as K, { quiet: true });\n        this.ttlBucket.remove(ttlKey);\n      }\n    });\n\n    this.flushing = false;\n  }\n}\n"],"mappings":"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","names":["EventEmitter","open","Store","name","options","exp","bucket","key","db","bucketName","origPut","origRemove","self","id","value","verOrOpts","ifVersion","quiet","result","ttlEntryKey","opts","version","current","keysToDelete","now","parts","ttlKey"]}